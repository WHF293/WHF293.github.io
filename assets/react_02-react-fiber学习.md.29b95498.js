import{_ as e,c as r,o as i,e as t}from"./app.c7796e3f.js";const _=JSON.parse('{"title":"02 react fiber 学习","description":"","frontmatter":{},"headers":[{"level":2,"title":"fiber 出现原因","slug":"fiber-出现原因","link":"#fiber-出现原因","children":[]},{"level":2,"title":"fiber 含义","slug":"fiber-含义","link":"#fiber-含义","children":[]},{"level":2,"title":"fiber 结构","slug":"fiber-结构","link":"#fiber-结构","children":[]},{"level":2,"title":"fiber 双缓存机制","slug":"fiber-双缓存机制","link":"#fiber-双缓存机制","children":[]}],"relativePath":"react/02-react-fiber学习.md","lastUpdated":1677142904000}'),a={name:"react/02-react-fiber学习.md"},c=t('<h1 id="_02-react-fiber-学习" tabindex="-1">02 react fiber 学习 <a class="header-anchor" href="#_02-react-fiber-学习" aria-hidden="true">#</a></h1><h2 id="fiber-出现原因" tabindex="-1">fiber 出现原因 <a class="header-anchor" href="#fiber-出现原因" aria-hidden="true">#</a></h2><ul><li><a href="https://juejin.cn/post/6844904202062282760#heading-0" target="_blank" rel="noreferrer">React技术揭秘2-1 Fiber架构</a></li></ul><p>react 16.8 之前虚拟 dom 更新采用的是递归比较，无法中断，页面渲染相对卡顿，为了解决这个问题 facebook 设置了一种可以异步终端更新的虚拟 dom，也就是 fiber</p><h2 id="fiber-含义" tabindex="-1">fiber 含义 <a class="header-anchor" href="#fiber-含义" aria-hidden="true">#</a></h2><ul><li>架构：react 16.8 之前 <code>Reconciler</code> 采用递归方式执行，数据保存在递归调用栈，所以叫做 <code>stack Reconciler</code>; 16.8 之后才有 fiber，所以现在被叫做 <code>fiber Reconciler</code></li><li>数据结构：每个 fiber 节点对应与一个组件，保存该组件的类型、dom 节点等信息</li><li>工作单元：保存了本次跟新中该组件的状态，要执行的工作</li></ul><h2 id="fiber-结构" tabindex="-1">fiber 结构 <a class="header-anchor" href="#fiber-结构" aria-hidden="true">#</a></h2><p>每个 fiber 节点都会保留 3 个用于恢复异步更新中断的指针</p><ul><li>return 指向父节点</li><li>child 指向子节点</li><li>sibling 指向右边第一个兄弟节点</li></ul><p>fiber 还有很多关于描述自身状态、本次跟新状态的节点</p><h2 id="fiber-双缓存机制" tabindex="-1">fiber 双缓存机制 <a class="header-anchor" href="#fiber-双缓存机制" aria-hidden="true">#</a></h2><p>fiber 双缓存机制：react 会在内存上创建两颗树，显示在当前屏幕上的叫 <code>current Fiber tree</code>, 在内存中构建的叫 <code>workInProgress Fiber tree</code></p><p>当 <code>workInProgress Fiber tree</code> 构建完之后会交给 <code>renderer（渲染器）</code>渲染</p><p>每次状态更新都会产生新的 workInProgress Fiber 树，通过 current 与 workInProgress 的替换，完成DOM更新。</p><blockquote><p>注意，初次渲染时 current tree 为 null</p></blockquote><p>当 workInProgress Fiber tree 构建完成，即已经完成以下这些工作</p><ul><li>fiber 节点的更新</li><li>diff</li><li>effectTag 的标记</li><li>effectList 的收集</li></ul><p>和 current 树相比，它们的结构上固然存在区别，变化的 fiber 节点也存在于 workInProgress 树，但要将这些节点应用到 DOM 上却不会循环整棵树，而是通过循环 effectList 这个链表来实现，这样保证了只针对有变化的节点做工作。</p><p><code>所以循环 effectList 链表去将有更新的 fiber 节点应用到页面上是 commit 阶段的主要工作</code></p>',19),l=[c];function o(d,f,n,b,s,h){return i(),r("div",null,l)}const u=e(a,[["render",o]]);export{_ as __pageData,u as default};

import{_ as n,c as s,o as a,e as p}from"./app.10177441.js";const C=JSON.parse('{"title":"pnpm yarn npm 区别","description":"","frontmatter":{},"headers":[{"level":2,"title":"npm1.x 和 npm2.x","slug":"npm1-x-和-npm2-x","link":"#npm1-x-和-npm2-x","children":[]},{"level":2,"title":"yarn 和 npm3.x","slug":"yarn-和-npm3-x","link":"#yarn-和-npm3-x","children":[]},{"level":2,"title":"pnpm","slug":"pnpm","link":"#pnpm","children":[]},{"level":2,"title":"pnpm 局限","slug":"pnpm-局限","link":"#pnpm-局限","children":[]}],"relativePath":"docs/pnpm-yarn-npm区别.md","lastUpdated":1677046022000}'),e={name:"docs/pnpm-yarn-npm区别.md"},l=p(`<h1 id="pnpm-yarn-npm-区别" tabindex="-1">pnpm yarn npm 区别 <a class="header-anchor" href="#pnpm-yarn-npm-区别" aria-hidden="true">#</a></h1><h2 id="npm1-x-和-npm2-x" tabindex="-1">npm1.x 和 npm2.x <a class="header-anchor" href="#npm1-x-和-npm2-x" aria-hidden="true">#</a></h2><p>会出现依赖里面又有依赖，如下：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">- node_modules</span></span>
<span class="line"><span style="color:#A6ACCD;">    - express</span></span>
<span class="line"><span style="color:#A6ACCD;">        - node_modules</span></span>
<span class="line"><span style="color:#A6ACCD;">            - 依赖包A</span></span>
<span class="line"><span style="color:#A6ACCD;">            - 依赖包B</span></span>
<span class="line"><span style="color:#A6ACCD;">        - libs</span></span>
<span class="line"><span style="color:#A6ACCD;">    - lodash</span></span>
<span class="line"><span style="color:#A6ACCD;">        - libs</span></span>
<span class="line"><span style="color:#A6ACCD;">        - node_modules</span></span>
<span class="line"><span style="color:#A6ACCD;">            - 依赖包A</span></span>
<span class="line"><span style="color:#A6ACCD;">            - 依赖包B</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>这样，当出现多个依赖使用到相同的依赖包的，会出现重复安装同一个依赖包的情况</p><h2 id="yarn-和-npm3-x" tabindex="-1">yarn 和 npm3.x <a class="header-anchor" href="#yarn-和-npm3-x" aria-hidden="true">#</a></h2><p>将依赖平铺, 假设项目依赖了 A包 和 B包， 而 A、B 两个包都依赖了 lodash（相同版本）， 那么 yarn 会把 lodash 平铺出来和 A、B 同级别</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">- node_modules</span></span>
<span class="line"><span style="color:#A6ACCD;">    - A</span></span>
<span class="line"><span style="color:#A6ACCD;">    - B</span></span>
<span class="line"><span style="color:#A6ACCD;">    - lodash</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>那如果 A、B 都依赖了 lodash，但是这两个包依赖的 lodash 版本不一致会怎么样</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">- node_modules</span></span>
<span class="line"><span style="color:#A6ACCD;">    - A</span></span>
<span class="line"><span style="color:#A6ACCD;">    - B</span></span>
<span class="line"><span style="color:#A6ACCD;">        - lodash@xx.xx.b</span></span>
<span class="line"><span style="color:#A6ACCD;">    - lodash@xx.xx.a</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>但是这种方式就会造成 <code>幽灵依赖</code>，即我项目里实际上没有安装 lodash，但是因为 yarn / npm3 把依赖给平铺了，所以我们在项目里是可以正常使用 lodash 提供的能力的。</p><p>假若我们使用了 lodash 提供的能力并应用在我们的项目中，那如果某一天 A、B 包都都移除了 lodash 作为他们的依赖，但是我们项目中有使用了 lodash，这个时候就会出现异常</p><p>而 pnpm 的出现就是为了解决上面说到的这两个问题的 - <code>重复安装相同的依赖包</code> 和 <code>幽灵依赖</code></p><h2 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-hidden="true">#</a></h2><ul><li><a href="https://www.pnpm.cn/" target="_blank" rel="noreferrer">pnpm 中文网</a></li></ul><p>pnpm 的实现思路是这样的，当你安装依赖的时候，它会帮你将依赖安装到电脑全局去，然后使用依赖包的时候通过软链 link 链接到依赖去</p><p>pnpm 官方配图</p><p><img src="https://www.pnpm.cn/assets/images/node-modules-structure-8ab301ddaed3b7530858b233f5b3be57.jpg" alt=""></p><p>即 pnpm 只会在全局保存一份，当其他依赖包用到以保存的依赖包时，通过软连接找到之前保存的依赖包就行了</p><p>这样就可以极大的节约磁盘内存又避免了幽灵依赖的问题</p><h2 id="pnpm-局限" tabindex="-1">pnpm 局限 <a class="header-anchor" href="#pnpm-局限" aria-hidden="true">#</a></h2><ul><li><a href="https://pnpm.io/zh/limitations" target="_blank" rel="noreferrer">pnpm 官网 - pnpm 的局限</a></li></ul><p>npm-shrinkwrap.json 和 package-lock.json 被忽略</p>`,23),o=[l];function t(r,c,i,d,m,h){return a(),s("div",null,o)}const y=n(e,[["render",t]]);export{C as __pageData,y as default};
